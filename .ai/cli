#!/bin/bash
set -e

# Version
VERSION="1.2.0"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Paths
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
AI_ROOT="$SCRIPT_DIR"
PROJECT_ROOT="$(dirname "$AI_ROOT")"

# Repository information
REPO_URL="https://github.com/betagouv/agnostic-ai"
VERSION_CHECK_FILE="$AI_ROOT/.version-check"

# Detect if running from agnostic-ai repo or from a project
# Check if we're in the agnostic-ai repo by looking for templates/plugins in parent directories
if [ -d "$PROJECT_ROOT/templates/plugins" ]; then
    # Running from agnostic-ai repo (development mode) - installed in a project
    PLUGINS_DIR="$PROJECT_ROOT/templates/plugins"
elif [ -d "$PROJECT_ROOT/../plugins" ] && [ -d "$PROJECT_ROOT/../.ai" ]; then
    # Running from agnostic-ai repo (development mode) - running from templates/.ai
    PLUGINS_DIR="$PROJECT_ROOT/../plugins"
else
    # Running from a user project - plugins need to be fetched
    PLUGINS_DIR=""
fi

CONFIG_FILE="$AI_ROOT/config.jsonc"

# Global cleanup trap
TEMP_PLUGINS_DIR=""
cleanup() {
    if [ -n "$TEMP_PLUGINS_DIR" ] && [ -d "$TEMP_PLUGINS_DIR" ]; then
        rm -rf "$TEMP_PLUGINS_DIR"
    fi
}
trap cleanup EXIT

# Get plugins directory (download if needed)
get_plugins_dir() {
    if [ -n "$PLUGINS_DIR" ]; then
        # Development mode - use local plugins
        echo "$PLUGINS_DIR"
    else
        # Production mode - download from GitHub
        if [ -z "$TEMP_PLUGINS_DIR" ]; then
            TEMP_PLUGINS_DIR=$(mktemp -d)

            git clone --depth 1 --quiet "$REPO_URL" "$TEMP_PLUGINS_DIR" 2>/dev/null || {
                echo -e "${RED}‚ùå Failed to download plugin list${NC}"
                exit 1
            }
        fi
        echo "$TEMP_PLUGINS_DIR/templates/plugins"
    fi
}

# Check if .ai/config.jsonc exists
check_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo -e "${RED}‚ùå No .ai/config.jsonc found${NC}"
        echo "   Run 'install.sh' first to initialize the project"
        exit 1
    fi
}

# Get installed plugins from config
get_installed_plugins() {
    if [ -f "$CONFIG_FILE" ]; then
        # Strip comments from JSONC
        local config_json=$(grep -v '^\s*//' "$CONFIG_FILE" | sed 's|//.*||g')

        # Check if jq is available
        if command -v jq &> /dev/null; then
            echo "$config_json" | jq -r '.plugins[]' 2>/dev/null || echo ""
        else
            # Fallback: simple grep/sed parsing
            echo "$config_json" | grep -o '"plugins":\s*\[.*\]' | sed 's/.*\[//' | sed 's/\].*//' | tr ',' '\n' | tr -d ' "' | grep -v '^$'
        fi
    fi
}

# List available and installed plugins
list_plugins() {
    echo -e "${BLUE}Available plugins:${NC}"
    echo ""

    # Get installed plugins
    installed_plugins=($(get_installed_plugins))

    # Get plugins directory
    local plugins_dir=$(get_plugins_dir)

    # List all plugins from templates/plugins/
    for plugin_path in "$plugins_dir"/*; do
        if [ -d "$plugin_path" ]; then
            plugin_name=$(basename "$plugin_path")

            # Check if installed
            is_installed=false
            for installed in "${installed_plugins[@]}"; do
                if [ "$installed" = "$plugin_name" ]; then
                    is_installed=true
                    break
                fi
            done

            if [ "$is_installed" = true ]; then
                echo -e "  ${GREEN}‚úì${NC} $plugin_name ${YELLOW}(installed)${NC}"
            else
                echo -e "    $plugin_name"
            fi
        fi
    done
    echo ""
}

# Add a plugin
add_plugin() {
    local plugin_name="$1"

    if [ -z "$plugin_name" ]; then
        echo -e "${RED}‚ùå Plugin name required${NC}"
        echo "   Usage: .ai/cli plugins add <plugin-name>"
        exit 1
    fi

    check_config

    # Get plugins directory
    local plugins_dir=$(get_plugins_dir)

    # Check if plugin exists
    if [ ! -d "$plugins_dir/$plugin_name" ]; then
        echo -e "${RED}‚ùå Plugin '$plugin_name' not found${NC}"
        echo "   Run '.ai/cli plugins list' to see available plugins"
        exit 1
    fi

    # Check if already installed
    installed_plugins=($(get_installed_plugins))
    for installed in "${installed_plugins[@]}"; do
        if [ "$installed" = "$plugin_name" ]; then
            echo -e "${YELLOW}‚ö†Ô∏è  Plugin '$plugin_name' already installed${NC}"
            exit 0
        fi
    done

    # Copy plugin files to .ai/<type>/<plugin-name>/
    echo -e "${BLUE}Installing plugin: $plugin_name${NC}"

    # Copy commands to .ai/commands/<plugin-name>/
    if [ -d "$plugins_dir/$plugin_name/commands" ]; then
        mkdir -p .ai/commands
        cp -r "$plugins_dir/$plugin_name/commands" ".ai/commands/$plugin_name"
        local cmd_count=$(find ".ai/commands/$plugin_name" -name "*.md" | wc -l | tr -d ' ')
        echo -e "${GREEN}‚úì${NC} Commands: $cmd_count ‚Üí .ai/commands/$plugin_name/"
    fi

    # Copy agents to .ai/agents/<plugin-name>/
    if [ -d "$plugins_dir/$plugin_name/agents" ]; then
        mkdir -p .ai/agents
        cp -r "$plugins_dir/$plugin_name/agents" ".ai/agents/$plugin_name"
        local agent_count=$(find ".ai/agents/$plugin_name" -name "*.md" | wc -l | tr -d ' ')
        echo -e "${GREEN}‚úì${NC} Agents: $agent_count ‚Üí .ai/agents/$plugin_name/"
    fi

    # Copy context to .ai/context/<plugin-name>/
    if [ -d "$plugins_dir/$plugin_name/context" ]; then
        mkdir -p .ai/context
        cp -r "$plugins_dir/$plugin_name/context" ".ai/context/$plugin_name"
        echo -e "${GREEN}‚úì${NC} Context ‚Üí .ai/context/$plugin_name/"
    fi

    # Update .ai/config.jsonc
    if command -v jq &> /dev/null; then
        # Strip comments, update with jq, then reconstruct with comments
        tmp=$(mktemp)
        config_json=$(grep -v '^\s*//' "$CONFIG_FILE" | sed 's|//.*||g')

        # Update plugins array
        echo "$config_json" | jq --arg plugin "$plugin_name" '.plugins += [$plugin]' > "$tmp"

        # Reconstruct JSONC with comments
        cat > "$CONFIG_FILE" << 'EOF'
{
  // Unified AI Configuration
  // This file is committed to git and shared across the team and all AI tools

  "version": "1.0.0",

  // Installed plugins
EOF
        echo "  \"plugins\": $(jq -c '.plugins' "$tmp")" >> "$CONFIG_FILE"
        echo "}" >> "$CONFIG_FILE"
        rm -f "$tmp"
    else
        # Fallback: manual update (preserves most of the file structure)
        sed -i.bak "s/\"plugins\": \[/\"plugins\": [\"$plugin_name\", /" "$CONFIG_FILE"
        rm -f "${CONFIG_FILE}.bak"
    fi

    echo -e "${GREEN}‚úÖ Plugin '$plugin_name' installed successfully${NC}"
}

# Migrate existing documentation to .ai/context
migrate() {
    echo -e "${BLUE}üîÑ Documentation Migration${NC}"
    echo ""

    # Detect configured IDEs by checking for their folders
    local configured_ides=()

    if [ -d "$PROJECT_ROOT/.claude" ]; then
        configured_ides+=("Claude Code")
    fi

    if [ -d "$PROJECT_ROOT/.cursor" ]; then
        configured_ides+=("Cursor")
    fi

    if [ ${#configured_ides[@]} -eq 0 ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  No IDE configured yet${NC}"
        echo ""
        echo "Please configure an IDE first:"
        echo -e "  ${GREEN}.ai/cli configure${NC}"
        echo ""
        exit 1
    fi

    echo "This command will help you migrate existing documentation to .ai/context/"
    echo ""
    echo -e "${BLUE}Detected IDE(s):${NC}"
    for ide in "${configured_ides[@]}"; do
        echo "  - $ide"
    done
    echo ""

    echo -e "${YELLOW}To migrate your documentation, run the following command in your IDE:${NC}"
    echo ""
    echo -e "  ${GREEN}/core:migrate${NC}"
    echo ""

    if [ ${#configured_ides[@]} -gt 1 ]; then
        echo -e "${BLUE}Note:${NC} You can run this command in any of your configured IDEs."
        echo ""
    fi

    echo "This will:"
    echo "  1. Find all documentation files (README.md, CLAUDE.md, AGENTS.md, .mdc files)"
    echo "  2. Extract content and organize it into .ai/context/ files"
    echo "  3. Clean up original files and add breadcrumb comments"
    echo "  4. Rename CLAUDE.md files to AGENTS.md"
    echo ""
}

# Configure IDE symlinks
configure() {
    echo -e "${BLUE}üîß IDE Configuration${NC}"
    echo ""

    # Get templates directory
    local templates_dir
    if [ -d "$PROJECT_ROOT/templates/ides" ]; then
        # Development mode
        templates_dir="$PROJECT_ROOT/templates"
    else
        # Production mode - download templates
        if [ -z "$TEMP_PLUGINS_DIR" ]; then
            TEMP_PLUGINS_DIR=$(mktemp -d)
            git clone --depth 1 --quiet "$REPO_URL" "$TEMP_PLUGINS_DIR" 2>/dev/null || {
                echo -e "${RED}‚ùå Failed to download templates${NC}"
                exit 1
            }
        fi
        templates_dir="$TEMP_PLUGINS_DIR/templates"
    fi

    # Discover available IDEs
    local available_ides=()
    local ide_index=1
    echo -e "${BLUE}Available IDEs:${NC}"

    for ide_path in "$templates_dir/ides"/*; do
        if [ -d "$ide_path" ] && [ -f "$ide_path/init.sh" ]; then
            local ide_name=$(basename "$ide_path")
            available_ides+=("$ide_name")

            # Get display name
            local display_name
            case $ide_name in
                claude) display_name="Claude Code" ;;
                cursor) display_name="Cursor" ;;
                *) display_name="$ide_name" ;;
            esac

            echo "  $ide_index) $display_name"
            ((ide_index++))
        fi
    done

    if [ ${#available_ides[@]} -eq 0 ]; then
        echo -e "${RED}‚ùå No IDEs found${NC}"
        exit 1
    fi

    echo ""
    echo -e "${YELLOW}Enter your choice(s) (e.g., '1' or '1 2' or '2 1'):${NC}"
    read -p "Your choice: " -r IDE_CHOICES </dev/tty
    echo ""

    # Parse IDE choices
    local selected_ides=()
    for choice in $IDE_CHOICES; do
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#available_ides[@]} ]; then
            local ide_name="${available_ides[$((choice-1))]}"
            selected_ides+=("$ide_name")
        else
            echo -e "${RED}‚ùå Invalid choice: $choice${NC}"
            exit 1
        fi
    done

    # Check if at least one IDE was selected
    if [ ${#selected_ides[@]} -eq 0 ]; then
        echo -e "${RED}‚ùå No IDE selected${NC}"
        exit 1
    fi

    # Configure each selected IDE
    echo -e "${BLUE}üîÑ Configuring IDE(s)...${NC}"
    echo ""

    for ide in "${selected_ides[@]}"; do
        # Get IDE display name
        local display_name
        case $ide in
            claude) display_name="Claude Code" ;;
            cursor) display_name="Cursor" ;;
            *) display_name="$ide" ;;
        esac

        echo -e "${BLUE}Setting up $display_name...${NC}"

        # Run IDE init script
        local init_script="$templates_dir/ides/$ide/init.sh"
        if [ -f "$init_script" ]; then
            bash "$init_script" || {
                echo -e "${YELLOW}‚ö†Ô∏è  $display_name setup failed${NC}"
            }

            # Update .gitignore
            local ide_gitignore="$templates_dir/ides/$ide/.gitignore"
            if [ -f "$ide_gitignore" ]; then
                touch .gitignore

                # Check if we already have this IDE's gitignore section
                local ide_marker="# ${ide} - Auto-generated symlinks"
                if ! grep -q "$ide_marker" .gitignore; then
                    # Add a separator and marker
                    echo "" >> .gitignore
                    echo "# =============================================================================" >> .gitignore
                    echo "$ide_marker" >> .gitignore
                    echo "# ‚ö†Ô∏è  Auto-generated - Do not edit manually" >> .gitignore
                    echo "# =============================================================================" >> .gitignore

                    # Append the gitignore content directly
                    while IFS= read -r line; do
                        # Skip empty lines and comments from template
                        if [[ -n "$line" ]] && [[ ! "$line" =~ ^# ]]; then
                            echo "$line" >> .gitignore
                        fi
                    done < "$ide_gitignore"

                    echo -e "${GREEN}‚úì${NC} Updated .gitignore for $display_name"
                fi
            fi

            echo ""
        else
            echo -e "${YELLOW}‚ö†Ô∏è  Init script not found for $display_name${NC}"
            echo ""
        fi
    done

    # Create config.local.jsonc with selected IDEs and embedded MCP configs
    local config_local="$AI_ROOT/config.local.jsonc"
    local new_config='{"ides":{}}'

    for ide in "${selected_ides[@]}"; do
        local mcp_template="$templates_dir/ides/$ide/mcp-config.jsonc"

        if [ -f "$mcp_template" ]; then
            # Read mcp-config template and embed it
            local mcp_json=$(grep -v '^\s*//' "$mcp_template" | sed 's|//.*||g' | jq -c '.')
            new_config=$(echo "$new_config" | jq --arg ide "$ide" --argjson mcp "$mcp_json" '.ides[$ide] = {"mcp-config": $mcp}')
            echo -e "${GREEN}‚úì${NC} Loaded MCP config for $ide"
        else
            # No mcp-config template, just add IDE name
            new_config=$(echo "$new_config" | jq --arg ide "$ide" '.ides[$ide] = {}')
        fi
    done

    # Write new format with comments
    cat > "$config_local" <<EOF
{
  // Local IDE configuration (gitignored)
  // Defines which IDEs are installed and configured with their MCP settings
EOF
    echo "  \"ides\": $(echo "$new_config" | jq '.ides')" >> "$config_local"
    echo "}" >> "$config_local"

    echo -e "${GREEN}‚úì${NC} Created .ai/config.local.jsonc"
    echo ""

    # Ensure config.local.jsonc is in .gitignore
    if [ -f "$PROJECT_ROOT/.gitignore" ]; then
        if ! grep -q "^\.ai/config\.local\.jsonc$" "$PROJECT_ROOT/.gitignore"; then
            echo "" >> "$PROJECT_ROOT/.gitignore"
            echo "# Local IDE configuration" >> "$PROJECT_ROOT/.gitignore"
            echo ".ai/config.local.jsonc" >> "$PROJECT_ROOT/.gitignore"
        fi
    fi

    echo -e "${GREEN}‚úÖ IDE configuration complete!${NC}"
    echo ""
}

# Validate and sync IDE gitignore entries
validate_and_sync_gitignore() {
    local ides=($(get_configured_ides))

    if [ ${#ides[@]} -eq 0 ]; then
        # No IDEs configured, skip validation
        return 0
    fi

    echo -e "${BLUE}Validating .gitignore entries...${NC}"

    local templates_dir
    if [ -d "$PROJECT_ROOT/templates/ides" ]; then
        templates_dir="$PROJECT_ROOT/templates/ides"
    else
        if [ -z "$TEMP_PLUGINS_DIR" ]; then
            TEMP_PLUGINS_DIR=$(mktemp -d)
            git clone --depth 1 --quiet "$REPO_URL" "$TEMP_PLUGINS_DIR" 2>/dev/null || {
                echo -e "${YELLOW}‚ö†Ô∏è  Could not download templates for validation${NC}"
                return 0
            }
        fi
        templates_dir="$TEMP_PLUGINS_DIR/templates/ides"
    fi

    touch "$PROJECT_ROOT/.gitignore"
    local missing_entries=()

    for ide in "${ides[@]}"; do
        local ide_gitignore="$templates_dir/$ide/.gitignore"

        if [ ! -f "$ide_gitignore" ]; then
            continue
        fi

        # Check each line from template exists in project .gitignore
        while IFS= read -r line; do
            # Skip empty lines and comments
            if [[ -n "$line" ]] && [[ ! "$line" =~ ^# ]]; then
                if ! grep -Fxq "$line" "$PROJECT_ROOT/.gitignore"; then
                    missing_entries+=("$line")
                fi
            fi
        done < "$ide_gitignore"
    done

    if [ ${#missing_entries[@]} -gt 0 ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Missing ${#missing_entries[@]} .gitignore entries${NC}"
        echo "   Adding missing entries..."

        for entry in "${missing_entries[@]}"; do
            echo "$entry" >> "$PROJECT_ROOT/.gitignore"
        done

        echo -e "${GREEN}‚úì${NC} Added missing .gitignore entries"
    else
        echo -e "${GREEN}‚úì${NC} All .gitignore entries are up to date"
    fi

    echo ""
}

# Update configuration and installed plugins
update() {
    check_config

    echo -e "${BLUE}Updating unified AI configuration...${NC}"
    echo ""

    # Validate and sync .gitignore entries for configured IDEs
    validate_and_sync_gitignore

    # Download update.sh from GitHub
    UPDATE_SCRIPT_URL="https://raw.githubusercontent.com/betagouv/agnostic-ai/main/update.sh"
    TEMP_UPDATE=$(mktemp)

    if curl -fsSL "$UPDATE_SCRIPT_URL" -o "$TEMP_UPDATE"; then
        bash "$TEMP_UPDATE"
        rm -f "$TEMP_UPDATE"
    else
        echo -e "${RED}‚ùå Failed to download update script${NC}"
        rm -f "$TEMP_UPDATE"
        exit 1
    fi
}

# ==============================================================================
# MCP Functions
# ==============================================================================

# Get configured IDEs from config.local.jsonc
get_configured_ides() {
    local config_local="$AI_ROOT/config.local.jsonc"

    if [ ! -f "$config_local" ]; then
        echo ""
        return
    fi

    # Strip comments and parse
    local config_json=$(grep -v '^\s*//' "$config_local" | sed 's|//.*||g')

    if command -v jq &> /dev/null; then
        # New format: object with IDE keys
        echo "$config_json" | jq -r '.ides | keys[]' 2>/dev/null || echo ""
    else
        echo ""
    fi
}

# Write MCP config to IDE-specific location
write_ide_mcp_config() {
    local ide="$1"
    local mcp_json="$2"

    # Load IDE-specific MCP config from config.local.jsonc
    local config_local="$AI_ROOT/config.local.jsonc"

    if [ ! -f "$config_local" ]; then
        echo -e "${RED}‚ùå config.local.jsonc not found${NC}"
        return 1
    fi

    # Strip comments and parse
    local config_json=$(grep -v '^\s*//' "$config_local" | sed 's|//.*||g')

    # Read IDE MCP config
    local mcp_config=$(echo "$config_json" | jq -c ".ides.\"$ide\".\"mcp-config\"" 2>/dev/null)

    if [ "$mcp_config" = "null" ] || [ -z "$mcp_config" ]; then
        echo -e "${RED}‚ùå MCP not configured for IDE: $ide${NC}"
        echo "   Run '.ai/cli configure' to set up MCP config"
        return 1
    fi

    # Read IDE config
    local location=$(echo "$mcp_config" | jq -r '.location')
    local strategy=$(echo "$mcp_config" | jq -r '.strategy')

    if [ "$location" = "null" ] || [ -z "$location" ]; then
        echo -e "${RED}‚ùå Invalid MCP config for $ide${NC}"
        return 1
    fi

    # Expand ~ in location
    location="${location/#\~/$HOME}"

    # Apply strategy
    case $strategy in
        overwrite)
            mkdir -p "$(dirname "$location")"
            echo "$mcp_json" > "$location"
            echo -e "${GREEN}‚úì${NC} $ide: $location"
            ;;
        merge-key)
            local key=$(echo "$mcp_config" | jq -r '.key')

            if [ ! -f "$location" ]; then
                echo -e "${RED}‚ùå Config file not found: $location${NC}"
                return 1
            fi

            # Extract mcpServers from input JSON
            local mcp_servers=$(echo "$mcp_json" | jq '.mcpServers')

            # Merge into existing config
            local updated_config=$(jq --argjson servers "$mcp_servers" ".$key = \$servers" "$location")
            echo "$updated_config" > "$location"
            echo -e "${GREEN}‚úì${NC} $ide: $location"
            ;;
        *)
            echo -e "${RED}‚ùå Unknown strategy: $strategy${NC}"
            return 1
            ;;
    esac
}

# Replace environment variables in JSON string
replace_env_vars() {
    local json_str="$1"
    local env_file="$PROJECT_ROOT/.env.local"

    if [ ! -f "$env_file" ]; then
        echo "$json_str"
        return
    fi

    while IFS= read -r line; do
        if [[ "$line" =~ ^([A-Z_][A-Z0-9_]*)=(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"
            json_str=$(echo "$json_str" | sed "s|.env.$key|$value|g")
        fi
    done < "$env_file"

    echo "$json_str"
}

# Install MCP templates
mcp_install() {
    echo -e "${BLUE}üì• Installing MCP templates...${NC}"
    echo ""

    local templates_dir
    if [ -d "$PROJECT_ROOT/templates/.ai/mcps" ]; then
        templates_dir="$PROJECT_ROOT/templates/.ai/mcps"
    else
        if [ -z "$TEMP_PLUGINS_DIR" ]; then
            TEMP_PLUGINS_DIR=$(mktemp -d)
            git clone --depth 1 --quiet "$REPO_URL" "$TEMP_PLUGINS_DIR" 2>/dev/null || {
                echo -e "${RED}‚ùå Failed to download MCP templates${NC}"
                exit 1
            }
        fi
        templates_dir="$TEMP_PLUGINS_DIR/templates/.ai/mcps"
    fi

    if [ ! -d "$templates_dir" ]; then
        echo -e "${RED}‚ùå MCP templates not found${NC}"
        exit 1
    fi

    # Copy templates
    mkdir -p "$AI_ROOT/mcps"
    (cd "$templates_dir" && cp -r . "$AI_ROOT/mcps/")

    echo -e "${GREEN}‚úÖ MCP templates installed to .ai/mcps/${NC}"
    echo ""

    # Create .env.local if it doesn't exist
    if [ ! -f "$PROJECT_ROOT/.env.local" ]; then
        if [ -f "$AI_ROOT/mcps/.env.example" ]; then
            cp "$AI_ROOT/mcps/.env.example" "$PROJECT_ROOT/.env.local"
            echo -e "${GREEN}‚úì${NC} Created .env.local from .env.example"
            echo ""
        fi
    fi

    # Add .env.local to .gitignore if needed
    if [ -f "$PROJECT_ROOT/.gitignore" ]; then
        if ! grep -q "^\.env\.local$" "$PROJECT_ROOT/.gitignore"; then
            echo "" >> "$PROJECT_ROOT/.gitignore"
            echo "# MCP environment variables" >> "$PROJECT_ROOT/.gitignore"
            echo ".env.local" >> "$PROJECT_ROOT/.gitignore"
        fi
    fi

    echo "Next steps:"
    echo "  1. Edit .env.local with your API keys and credentials"
    echo "  2. Customize .ai/mcps/config.jsonc if needed"
    echo "  3. Run: ./ai/cli mcp use <server-name>"
    echo ""
}

# List available MCP servers
mcp_list() {
    local mcp_config="$AI_ROOT/mcps/config.jsonc"

    if [ ! -f "$mcp_config" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  No MCP configuration found${NC}"
        echo "   Run '.ai/cli mcp install' first"
        exit 1
    fi

    echo -e "${BLUE}Available MCP servers:${NC}"
    echo ""

    # Strip comments from JSONC
    local config_json=$(grep -v '^\s*//' "$mcp_config")

    # Get all server names and descriptions
    echo "$config_json" | jq -r '.mcpServers | to_entries[] | "    \(.key)\n      \(.value.description)"'
}

# Enable MCP server(s)
mcp_use() {
    local server_names=("$@")

    if [ ${#server_names[@]} -eq 0 ]; then
        echo -e "${RED}‚ùå Server name(s) required${NC}"
        echo "   Usage: .ai/cli mcp use <server-name> [server-name2 ...]"
        exit 1
    fi

    local mcp_config="$AI_ROOT/mcps/config.jsonc"

    if [ ! -f "$mcp_config" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  No MCP configuration found${NC}"
        echo "   Run '.ai/cli mcp install' first"
        exit 1
    fi

    local ides=($(get_configured_ides))

    if [ ${#ides[@]} -eq 0 ]; then
        echo -e "${RED}‚ùå No IDE configured yet${NC}"
        echo "   Run '.ai/cli configure' first to set up an IDE"
        exit 1
    fi

    local config_json=$(grep -v '^\s*//' "$mcp_config")

    # Check if jq is available
    if ! command -v jq &> /dev/null; then
        echo -e "${RED}‚ùå 'jq' is required for MCP management${NC}"
        exit 1
    fi

    # Build new MCP configuration with selected servers
    local new_mcp_config='{"mcpServers":{}}'

    for server_name in "${server_names[@]}"; do
        # Check if server exists
        local server_exists=$(echo "$config_json" | jq -e ".mcpServers.\"$server_name\"" > /dev/null 2>&1 && echo "true" || echo "false")

        if [ "$server_exists" = "false" ]; then
            echo -e "${RED}‚ùå MCP server '$server_name' not found in config.jsonc${NC}"
            echo ""
            echo "   Run '.ai/cli mcp list' to see configured servers"
            echo "   Or search for it at: ${BLUE}https://mcpservers.org/search?query=$server_name${NC}"
            echo ""
            echo "   To add a new MCP server:"
            echo "   1. Find it at https://mcpservers.org/"
            echo "   2. Add configuration to .ai/mcps/config.jsonc"
            echo "   3. Add environment variables to .env.local"
            echo "   4. Run '.ai/cli mcp use $server_name'"
            exit 1
        fi

        # Extract server config
        local server_config=$(echo "$config_json" | jq ".mcpServers.\"$server_name\"")

        # Check for required env variables
        local env_keys=$(echo "$server_config" | jq -r '.env // {} | keys[]' 2>/dev/null)

        if [ -n "$env_keys" ]; then
            while IFS= read -r env_key; do
                # Get the value placeholder
                local env_value=$(echo "$server_config" | jq -r ".env.\"$env_key\"")

                # Check if it's a .env.KEY placeholder
                if [[ "$env_value" =~ ^\.env\.(.+)$ ]]; then
                    local actual_key="${BASH_REMATCH[1]}"

                    # Check if variable exists in .env.local
                    if [ -f "$PROJECT_ROOT/.env.local" ]; then
                        # Check if key exists and has a non-empty value
                        local actual_value=$(grep "^$actual_key=" "$PROJECT_ROOT/.env.local" | cut -d'=' -f2-)

                        if [ -z "$actual_value" ]; then
                            echo -e "${RED}‚ùå Missing or empty environment variable: $actual_key${NC}"
                            echo "   Add a value in .env.local: $actual_key=<your-value>"
                            echo ""
                            echo "   Example for $server_name:"
                            echo "   $actual_key=your_actual_api_key_here"
                            exit 1
                        fi
                    else
                        echo -e "${RED}‚ùå .env.local not found${NC}"
                        echo "   Run '.ai/cli mcp install' first"
                        exit 1
                    fi
                fi
            done <<< "$env_keys"
        fi

        new_mcp_config=$(echo "$new_mcp_config" | jq --arg name "$server_name" --argjson config "$server_config" '.mcpServers[$name] = $config')
    done

    new_mcp_config=$(replace_env_vars "$new_mcp_config")

    local formatted_config=$(echo "$new_mcp_config" | jq '.')

    echo -e "${BLUE}Enabling MCP servers: ${server_names[*]}${NC}"
    echo ""

    for ide in "${ides[@]}"; do
        write_ide_mcp_config "$ide" "$formatted_config"
    done

    echo ""
    echo -e "${GREEN}‚úÖ MCP servers enabled successfully${NC}"
    echo "   Restart your IDE(s) to apply changes"
    echo ""
}

# Disable MCP server(s)
mcp_unuse() {
    local servers_to_remove=("$@")

    if [ ${#servers_to_remove[@]} -eq 0 ]; then
        echo -e "${RED}‚ùå Server name(s) required${NC}"
        echo "   Usage: .ai/cli mcp unuse <server-name> [server-name2 ...]"
        exit 1
    fi

    local ides=($(get_configured_ides))

    if [ ${#ides[@]} -eq 0 ]; then
        echo -e "${RED}‚ùå No IDE configured yet${NC}"
        exit 1
    fi

    if ! command -v jq &> /dev/null; then
        echo -e "${RED}‚ùå 'jq' is required for MCP management${NC}"
        exit 1
    fi

    # Get currently active servers from first IDE
    local first_ide="${ides[0]}"
    local config_local="$AI_ROOT/config.local.jsonc"
    local config_json=$(grep -v '^\s*//' "$config_local" | sed 's|//.*||g')
    local mcp_config=$(echo "$config_json" | jq -c ".ides.\"$first_ide\".\"mcp-config\"" 2>/dev/null)

    if [ "$mcp_config" = "null" ] || [ -z "$mcp_config" ]; then
        echo -e "${RED}‚ùå MCP not configured for IDE: $first_ide${NC}"
        exit 1
    fi

    local location=$(echo "$mcp_config" | jq -r '.location')
    location="${location/#\~/$HOME}"

    if [ ! -f "$location" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  No active MCP servers${NC}"
        exit 0
    fi

    local strategy=$(echo "$mcp_config" | jq -r '.strategy')
    local active_servers=()

    if [ "$strategy" = "merge-key" ]; then
        local key=$(echo "$mcp_config" | jq -r '.key')
        active_servers=($(jq -r ".$key | keys[]" "$location" 2>/dev/null))
    else
        active_servers=($(jq -r '.mcpServers | keys[]' "$location" 2>/dev/null))
    fi

    # Remove specified servers
    local remaining_servers=()
    for active in "${active_servers[@]}"; do
        local should_remove=false
        for remove in "${servers_to_remove[@]}"; do
            if [ "$active" = "$remove" ]; then
                should_remove=true
                break
            fi
        done

        if [ "$should_remove" = false ]; then
            remaining_servers+=("$active")
        fi
    done

    if [ ${#remaining_servers[@]} -eq 0 ]; then
        echo -e "${BLUE}Disabling all MCP servers${NC}"
        echo ""

        local empty_config='{"mcpServers":{}}'
        local formatted_config=$(echo "$empty_config" | jq '.')

        for ide in "${ides[@]}"; do
            write_ide_mcp_config "$ide" "$formatted_config"
        done
    else
        mcp_use "${remaining_servers[@]}"
        return
    fi

    echo ""
    echo -e "${GREEN}‚úÖ MCP servers disabled successfully${NC}"
    echo "   Restart your IDE(s) to apply changes"
    echo ""
}

# Check for new version (cached, once per day)
check_version_update() {
    # Only check if not in dev mode
    if [ -n "$PLUGINS_DIR" ]; then
        return 0
    fi

    # Check if we should check (once per day)
    if [ -f "$VERSION_CHECK_FILE" ]; then
        local last_check=$(cat "$VERSION_CHECK_FILE")
        local now=$(date +%s)
        local day_ago=$((now - 86400))

        if [ "$last_check" -gt "$day_ago" ]; then
            # Checked recently, skip
            return 0
        fi
    fi

    # Fetch latest version from GitHub (timeout after 2 seconds)
    local latest_version=$(curl -s --max-time 2 "https://raw.githubusercontent.com/betagouv/agnostic-ai/main/templates/.ai/cli" 2>/dev/null | grep '^VERSION=' | head -1 | cut -d'"' -f2)

    # Save check timestamp
    date +%s > "$VERSION_CHECK_FILE"

    # Compare versions
    if [ -n "$latest_version" ] && [ "$latest_version" != "$VERSION" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  New version available: $latest_version (current: $VERSION)${NC}"
        echo "   Run '.ai/cli update' to upgrade"
        echo ""
    fi
}

# Show version
show_version() {
    echo "agnostic-ai CLI version $VERSION"
    echo ""
    echo "Repository: $REPO_URL"
    echo "Local path: $AI_ROOT"
    echo ""
}

# Show help
show_help() {
    echo "agnostic-ai - Unified AI Configuration Tool"
    echo ""
    echo "Share one AI configuration across all your AI coding tools"
    echo ""
    echo "Usage:"
    echo "  .ai/cli migrate                  Migrate documentation to .ai/context"
    echo "  .ai/cli configure                Configure IDE symlinks"
    echo "  .ai/cli plugins list             List available plugins"
    echo "  .ai/cli plugins add <plugin>     Install a plugin"
    echo "  .ai/cli mcp install              Install/update MCP templates"
    echo "  .ai/cli mcp list                 List available MCP servers"
    echo "  .ai/cli mcp use <server...>      Enable MCP server(s)"
    echo "  .ai/cli mcp unuse <server...>    Disable MCP server(s)"
    echo "  .ai/cli update                   Update configuration and plugins"
    echo "  .ai/cli --version                Show version information"
    echo "  .ai/cli help                     Show this help"
    echo ""
}

# Check for updates (async, cached)
check_version_update

# Main command dispatcher
case "${1:-}" in
    migrate)
        migrate
        ;;
    configure)
        configure
        ;;
    plugins)
        case "${2:-}" in
            list)
                list_plugins
                ;;
            add)
                add_plugin "$3"
                ;;
            *)
                echo -e "${RED}‚ùå Unknown plugins command: ${2:-}${NC}"
                echo "   Usage: .ai/cli plugins [list|add]"
                exit 1
                ;;
        esac
        ;;
    mcp)
        case "${2:-}" in
            install)
                mcp_install
                ;;
            list)
                mcp_list
                ;;
            use)
                shift 2
                mcp_use "$@"
                ;;
            unuse)
                shift 2
                mcp_unuse "$@"
                ;;
            *)
                echo -e "${RED}‚ùå Unknown mcp command: ${2:-}${NC}"
                echo "   Usage: .ai/cli mcp [install|list|use|unuse]"
                exit 1
                ;;
        esac
        ;;
    update)
        update
        ;;
    --version|-v|version)
        show_version
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        echo -e "${RED}‚ùå Unknown command: ${1:-}${NC}"
        show_help
        exit 1
        ;;
esac
